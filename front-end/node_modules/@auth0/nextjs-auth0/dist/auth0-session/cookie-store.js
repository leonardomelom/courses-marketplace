"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var jose = tslib_1.__importStar(require("jose"));
var cookie_1 = require("cookie");
var hkdf_1 = require("./utils/hkdf");
var debug_1 = tslib_1.__importDefault(require("./utils/debug"));
var debug = debug_1.default('cookie-store');
var epoch = function () { return (Date.now() / 1000) | 0; }; // eslint-disable-line no-bitwise
var MAX_COOKIE_SIZE = 4096;
var alg = 'dir';
var enc = 'A256GCM';
var notNull = function (value) { return value !== null; };
var assert = function (bool, msg) {
    if (!bool) {
        throw new Error(msg);
    }
};
var CookieStore = /** @class */ (function () {
    function CookieStore(config, Cookies) {
        this.config = config;
        this.Cookies = Cookies;
        var _a = this.config.session, _b = _a.cookie, transient = _b.transient, cookieConfig = tslib_1.__rest(_b, ["transient"]), sessionName = _a.name;
        var cookieOptions = tslib_1.__assign({}, cookieConfig);
        if (!transient) {
            cookieOptions.expires = new Date();
        }
        var emptyCookie = cookie_1.serialize(sessionName + ".0", '', cookieOptions);
        this.chunkSize = MAX_COOKIE_SIZE - emptyCookie.length;
    }
    CookieStore.prototype.getKeys = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var secret, secrets, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!!this.keys) return [3 /*break*/, 2];
                        secret = this.config.secret;
                        secrets = Array.isArray(secret) ? secret : [secret];
                        _a = this;
                        return [4 /*yield*/, Promise.all(secrets.map(hkdf_1.encryption))];
                    case 1:
                        _a.keys = _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/, this.keys];
                }
            });
        });
    };
    CookieStore.prototype.encrypt = function (payload, _a) {
        var iat = _a.iat, uat = _a.uat, exp = _a.exp;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _b, key;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getKeys()];
                    case 1:
                        _b = tslib_1.__read.apply(void 0, [_c.sent(), 1]), key = _b[0];
                        return [4 /*yield*/, new jose.EncryptJWT(tslib_1.__assign({}, payload)).setProtectedHeader({ alg: alg, enc: enc, uat: uat, iat: iat, exp: exp }).encrypt(key)];
                    case 2: return [2 /*return*/, _c.sent()];
                }
            });
        });
    };
    CookieStore.prototype.decrypt = function (jwe) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var keys, err, keys_1, keys_1_1, key, e_1, e_2_1;
            var e_2, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getKeys()];
                    case 1:
                        keys = _b.sent();
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 9, 10, 11]);
                        keys_1 = tslib_1.__values(keys), keys_1_1 = keys_1.next();
                        _b.label = 3;
                    case 3:
                        if (!!keys_1_1.done) return [3 /*break*/, 8];
                        key = keys_1_1.value;
                        _b.label = 4;
                    case 4:
                        _b.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, jose.jwtDecrypt(jwe, key)];
                    case 5: return [2 /*return*/, _b.sent()];
                    case 6:
                        e_1 = _b.sent();
                        err = e_1;
                        return [3 /*break*/, 7];
                    case 7:
                        keys_1_1 = keys_1.next();
                        return [3 /*break*/, 3];
                    case 8: return [3 /*break*/, 11];
                    case 9:
                        e_2_1 = _b.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 11];
                    case 10:
                        try {
                            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 11: throw err;
                }
            });
        });
    };
    CookieStore.prototype.calculateExp = function (iat, uat) {
        var absoluteDuration = this.config.session.absoluteDuration;
        var _a = this.config.session, rolling = _a.rolling, rollingDuration = _a.rollingDuration;
        if (typeof absoluteDuration !== 'number') {
            return uat + rollingDuration;
        }
        if (!rolling) {
            return iat + absoluteDuration;
        }
        return Math.min(uat + rollingDuration, iat + absoluteDuration);
    };
    CookieStore.prototype.read = function (req) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cookies, _a, sessionName, rollingDuration, absoluteDuration, iat, uat, exp, existingSessionValue, _b, header, payload, err_1;
            var _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        cookies = new this.Cookies().getAll(req);
                        _a = this.config.session, sessionName = _a.name, rollingDuration = _a.rollingDuration, absoluteDuration = _a.absoluteDuration;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 4, , 5]);
                        if (sessionName in cookies) {
                            // get JWE from unchunked session cookie
                            debug('reading session from %s cookie', sessionName);
                            existingSessionValue = cookies[sessionName];
                        }
                        else if (sessionName + ".0" in cookies) {
                            // get JWE from chunked session cookie
                            // iterate all cookie names
                            // match and filter for the ones that match sessionName.<number>
                            // sort by chunk index
                            // concat
                            existingSessionValue = Object.entries(cookies)
                                .map(function (_a) {
                                var _b = tslib_1.__read(_a, 2), cookie = _b[0], value = _b[1];
                                var match = cookie.match("^" + sessionName + "\\.(\\d+)$");
                                if (match) {
                                    return [match[1], value];
                                }
                                return null;
                            })
                                .filter(notNull)
                                .sort(function (_a, _b) {
                                var _c = tslib_1.__read(_a, 1), a = _c[0];
                                var _d = tslib_1.__read(_b, 1), b = _d[0];
                                return parseInt(a, 10) - parseInt(b, 10);
                            })
                                .map(function (_a) {
                                var _b = tslib_1.__read(_a, 2), i = _b[0], chunk = _b[1];
                                debug('reading session chunk from %s.%d cookie', sessionName, i);
                                return chunk;
                            })
                                .join('');
                        }
                        if (!existingSessionValue) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.decrypt(existingSessionValue)];
                    case 2:
                        _b = _d.sent(), header = _b.protectedHeader, payload = _b.payload;
                        (_c = header, iat = _c.iat, uat = _c.uat, exp = _c.exp);
                        // check that the existing session isn't expired based on options when it was established
                        assert(exp > epoch(), 'it is expired based on options when it was established');
                        // check that the existing session isn't expired based on current rollingDuration rules
                        if (rollingDuration) {
                            assert(uat + rollingDuration > epoch(), 'it is expired based on current rollingDuration rules');
                        }
                        // check that the existing session isn't expired based on current absoluteDuration rules
                        if (typeof absoluteDuration === 'number') {
                            assert(iat + absoluteDuration > epoch(), 'it is expired based on current absoluteDuration rules');
                        }
                        return [2 /*return*/, [payload, iat]];
                    case 3: return [3 /*break*/, 5];
                    case 4:
                        err_1 = _d.sent();
                        debug('error handling session %O', err_1);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/, []];
                }
            });
        });
    };
    CookieStore.prototype.save = function (req, res, session, createdAt) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, _b, transient, cookieConfig, sessionName, cookieSetter, cookies, _c, _d, cookieName, uat, iat, exp, cookieOptions, value, chunkCount, i, chunkValue, chunkCookieName, _e, _f, cookieName;
            var e_3, _g, e_4, _h;
            return tslib_1.__generator(this, function (_j) {
                switch (_j.label) {
                    case 0:
                        _a = this.config.session, _b = _a.cookie, transient = _b.transient, cookieConfig = tslib_1.__rest(_b, ["transient"]), sessionName = _a.name;
                        cookieSetter = new this.Cookies();
                        cookies = cookieSetter.getAll(req);
                        if (!session) {
                            debug('clearing all matching session cookies');
                            try {
                                for (_c = tslib_1.__values(Object.keys(cookies)), _d = _c.next(); !_d.done; _d = _c.next()) {
                                    cookieName = _d.value;
                                    if (cookieName.match("^" + sessionName + "(?:\\.\\d)?$")) {
                                        cookieSetter.clear(cookieName, cookieConfig);
                                        cookieSetter.commit(res, this.config.session.name);
                                    }
                                }
                            }
                            catch (e_3_1) { e_3 = { error: e_3_1 }; }
                            finally {
                                try {
                                    if (_d && !_d.done && (_g = _c.return)) _g.call(_c);
                                }
                                finally { if (e_3) throw e_3.error; }
                            }
                            return [2 /*return*/];
                        }
                        uat = epoch();
                        iat = typeof createdAt === 'number' ? createdAt : uat;
                        exp = this.calculateExp(iat, uat);
                        cookieOptions = tslib_1.__assign({}, cookieConfig);
                        if (!transient) {
                            cookieOptions.expires = new Date(exp * 1000);
                        }
                        debug('found session, creating signed session cookie(s) with name %o(.i)', sessionName);
                        return [4 /*yield*/, this.encrypt(session, { iat: iat, uat: uat, exp: exp })];
                    case 1:
                        value = _j.sent();
                        chunkCount = Math.ceil(value.length / this.chunkSize);
                        if (chunkCount > 1) {
                            debug('cookie size greater than %d, chunking', this.chunkSize);
                            for (i = 0; i < chunkCount; i++) {
                                chunkValue = value.slice(i * this.chunkSize, (i + 1) * this.chunkSize);
                                chunkCookieName = sessionName + "." + i;
                                cookieSetter.set(chunkCookieName, chunkValue, cookieOptions);
                            }
                            if (sessionName in cookies) {
                                cookieSetter.clear(sessionName, cookieConfig);
                            }
                        }
                        else {
                            cookieSetter.set(sessionName, value, cookieOptions);
                            try {
                                for (_e = tslib_1.__values(Object.keys(cookies)), _f = _e.next(); !_f.done; _f = _e.next()) {
                                    cookieName = _f.value;
                                    if (cookieName.match("^" + sessionName + "\\.\\d$")) {
                                        cookieSetter.clear(cookieName, cookieConfig);
                                    }
                                }
                            }
                            catch (e_4_1) { e_4 = { error: e_4_1 }; }
                            finally {
                                try {
                                    if (_f && !_f.done && (_h = _e.return)) _h.call(_e);
                                }
                                finally { if (e_4) throw e_4.error; }
                            }
                        }
                        cookieSetter.commit(res, this.config.session.name);
                        return [2 /*return*/];
                }
            });
        });
    };
    return CookieStore;
}());
exports.default = CookieStore;
//# sourceMappingURL=cookie-store.js.map